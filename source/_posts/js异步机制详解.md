---
title: js异步机制详解.md
date: 2021-04-13 10:29:18
tags: js异步
---
## JavaScript 异步机制详解

> JavaScript 是单线程的。
js创立之初是作为浏览器脚本语言，主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定js同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
所以，为了避免复杂性，从一诞生，js就是单线程，这已经成了这门语言的核心特征，目前来看，这个特征将不会改变

> 开始疑惑了，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？
> 本篇文章就主要讲解一下 JavaScript 怎么处理异步问题。


### 同步与异步

从时间的纬度上
![An image](./images/1618293573407.jpg)

#### 同步

如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。
如下所示：

```javascript
//在函数返回时，获得了预期值，即2的平方根
Math.sqrt(2);
//在函数返回时，获得了预期的效果，即在控制台上打印了'hello'
console.log("hello");
```

上面两个函数就是同步的。

##### 如果函数是同步的，即使调用函数执行的任务比较耗时，也会`一直等待`直到得到预期结果。

#### 异步

如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。
如下所示：

```javascript
//读取文件
fs.readFile("hello.txt", "utf8", function(err, data) {
  console.log(data);
});
//网络请求
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = xxx; // 添加回调函数
xhr.open("GET", url);
xhr.send(); // 发起函数
```

上述示例中读取文件函数 `readFile`和网络请求的发起函数 send 都将执行耗时操作，虽然函数会立即返回，但是不能立刻获取预期的结果，
因为`耗时操作交给其他线程`执行，暂时获取不到预期结果（后面介绍）。
而在 JavaScript 中通过回调函数 `function(err, data) { console.log(data); }`和 `onreadystatechange` ，
在耗时操作执行完成后把相应的结果信息传递给回调函数，通知执行 JavaScript 代码的线程执行回调。

#### 如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。

### 单线程与多线程

在上面介绍异步的过程中就可能会纳闷：既然 JavaScript 是单线程，怎么还存在异步，那些耗时操作到底交给谁去执行了？
JavaScript 其实就是一门语言，说是单线程还是多线程得结合具体运行环境。JS 的运行通常是在浏览器中进行的，具体由 JS 引擎去解析和运行。下面我们来具体了解一下浏览器。

#### 浏览器

目前最为流行的浏览器为：Chrome，IE，Safari，FireFox，Opera。浏览器的内核是多线程的
一个浏览器通常由以下几个常驻的线程：

- 渲染引擎线程：顾名思义，该线程负责页面的渲染
- JS 引擎线程：负责 JS 的解析和执行
- 定时触发器线程：处理定时事件，比如 setTimeout, setInterval
- 事件触发线程：处理 DOM 事件
- 异步 http 请求线程：处理 http 请求

需要注意的是，渲染线程和 JS 引擎线程是不能同时进行的。渲染线程在执行任务的时候，JS 引擎线程会被挂起。因为 JS 可以操作 DOM，若在渲染中 JS 处理了 DOM，浏览器可能就不知所措了。

#### js 引擎

> 通常讲到浏览器的时候，我们会说到两个引擎：渲染引擎和 JS 引擎。渲染引擎就是如何渲染页面，Chrome／Safari／Opera 用的是 Webkit 引擎，IE 用的是 Trident 引擎，FireFox 用的是 Gecko 引擎。不同的引擎对同一个样式的实现不一致，就导致了经常被人诟病的浏览器样式兼容性问题。这里我们不做具体讨论。
> JS 引擎可以说是 JS 虚拟机，负责 JS 代码的解析和执行。通常包括以下几个步骤：

- 词法分析：将源代码分解为有意义的分词
- 语法分析：用语法分析器将分词解析成语法树
- 代码生成：生成机器能运行的代码
- 代码执行

不同浏览器的 JS 引擎也各不相同，Chrome 用的是 V8，FireFox 用的是 SpiderMonkey，Safari 用的是 JavaScriptCore，IE 用的是 Chakra。
之所以说 JavaScript 是单线程，就是因为浏览器在运行时只开启了一个 JS 引擎线程来解析和执行 JS。那为什么只有一个引擎呢？如果同时有两个线程去操作 DOM，浏览器是不是又要不知所措了。

所以，虽然 JavaScript 是单线程的，可是浏览器内部不是单线程的。一些 I/O 操作、定时器的计时和事件监听（click, keydown...）等都是由浏览器提供的其他线程来完成的。

### 消息队列与事件循环

通过以上了解，可以知道其实 JavaScript 也是通过 JS 引擎线程与浏览器中其他线程交互协作实现异步。但是回调函数具体何时加入到 JS 引擎线程中执行？执行顺序是怎么样的？

这一切的解释就需要继续了解消息队列和事件循环。

![An image](./images/1618295782783.jpg)

如上图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。

>当我们调用一个方法的时候，js会生成一个与这个方法相对应的执行环境，也叫执行上下文，这个执行环境存在着这个方法的私有作用域、参数、this对象等等。因为js是单线程的，同一时间只能执行一个方法，所以当一系列的方法被依次调用的时候，js会先解析这些方法，把其中的同步任务按照执行顺序排队到一个地方，这个地方叫做`执行栈(execution context stack)`。

右边的堆用来存储声明的变量、对象。

下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和 setTimeout 中待执行的事件，每个异步任务都和回调函数相关联。
>当我们发出一个ajax请求，他并不会立刻返回结果，为了防止浏览器出现假死或者空白，主线程会把这个异步任务挂起(pending)，继续执行执行栈中的其他任务，等异步任务返回结果后，js会将这个异步任务按照执行顺序，加入到与执行栈不同的另一个队列，也就是`事件队列`。


JS 引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。

JS 引擎线程从消息队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这就叫`事件循环`。
![An image](./images/1618299642591.jpg)
关于事件循环流程分解如下：
> 1. 宿主环境为JavaScript创建线程时，会创建堆(heap)和栈(stack)，堆内存储JavaScript对象，栈内存储执行上下文；
> 2. 栈内执行上下文的同步任务按序执行，执行完即退栈，而当异步任务执行时，该异步任务进入等待状态（不入栈），同时通知线程：当触发该事件时（或该异步操作响应返回时），需向消息队列插入一个事件消息；
> 3. 当事件触发或响应返回时，线程向消息队列插入该事件消息（包含事件及回调）
> 4. 当栈内同步任务执行完毕后，线程从消息队列取出一个事件消息，其对应异步任务（函数）入栈，执行回调函数，如果未绑定回调，这个消息会被丢弃，执行完任务后退栈。
> 5. 当线程空闲（即执行栈清空）时继续拉取消息队列下一轮消息（next tick，事件循环流转一次称为一次tick）



![An image](./images/1618296018560.jpg)
上图以 AJAX 异步请求为例，发起异步任务后，由 AJAX 线程执行耗时的异步操作，而 JS 引擎线程继续执行堆中的其他同步任务，直到栈中的所有同步任务执行完毕。然后，从消息队列中依次按照顺序取出消息作为一个同步任务在 JS 引擎线程中执行，那么 AJAX 的回调函数就会在某一时刻被调用执行。

### 请分析

执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（>5s）后，再点击两下，整个过程的输出结果是什么？

```javascript
setTimeout(function() {
  for (var i = 0; i < 100000000; i++) {}
  console.log("timer a");
}, 0);

for (var j = 0; j < 5; j++) {
  console.log(j);
}
setTimeout(function() {
  console.log("timer b");
}, 0);
function waitFiveSeconds() {
  var now = new Date().getTime();
  while (new Date().getTime() - now < 5000) {}
  console.log("finished waiting");
}
document.addEventListener("click", function() {
  console.log("click");
});
console.log("click begin");
waitFiveSeconds();
```

##
